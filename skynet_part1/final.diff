diff --git a/skynet_part1/dh/__init__.py b/skynet_part1/dh/__init__.py
index 6d6f182..d0c08c0 100644
--- a/skynet_part1/dh/__init__.py
+++ b/skynet_part1/dh/__init__.py
@@ -5,7 +5,7 @@ from lib.helpers import read_hex
 
 # Project TODO: Is this the best choice of prime? Why? Why not? Feel free to replace!
 
-# 1536 bit safe prime for Diffie-Hellman key exchange
+# 3072 bit safe prime for Diffie-Hellman key exchange
 # obtained from RFC 3526
 raw_prime = """FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
 29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
@@ -14,7 +14,15 @@ E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED
 EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3D
 C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F
 83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
-670C354E 4ABC9804 F1746C08 CA237327 FFFFFFFF FFFFFFFF"""
+670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B
+E39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9
+DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA0510
+15728E5A 8AAAC42D AD33170D 04507A33 A85521AB DF1CBA64
+ECFB8504 58DBEF0A 8AEA7157 5D060C7D B3970F85 A6E1E4C7
+ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226 1AD2EE6B
+F12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200C
+BBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB31
+43DB5BFC E0FD108E 4B82D120 A93AD2CA FFFFFFFF FFFFFFFF"""
 # Convert from the value supplied in the RFC to an integer
 prime = read_hex(raw_prime)
 
@@ -23,8 +31,17 @@ prime = read_hex(raw_prime)
 def create_dh_key():
     # Creates a Diffie-Hellman key
     # Returns (public, private)
-    a = random.randint(0, int(2**8))
-    return (a, a)
+    # The end value used in the PRNG
+    q = (prime - 1)/2
+    # The random value which has been generated by one party
+    a = random.randint(2, q - 2)
+    # The private key which is used to work out the shared secret
+    my_private_value = pow(2, a)
+    # The public key which is generated and sent to the other party.
+    my_public = pow(2, my_private, prime)
+    # The function will return both the private key of the user and the public
+    # value sent to the other party.
+    return (my_public, my_private_value)
 
 def calculate_dh_secret(their_public, my_private):
     # Calculate the shared secret
diff --git a/skynet_part1/dh/__pycache__/__init__.cpython-35.pyc b/skynet_part1/dh/__pycache__/__init__.cpython-35.pyc
new file mode 100644
index 0000000..9b44725
Binary files /dev/null and b/skynet_part1/dh/__pycache__/__init__.cpython-35.pyc differ
diff --git a/skynet_part1/lib/__pycache__/__init__.cpython-35.pyc b/skynet_part1/lib/__pycache__/__init__.cpython-35.pyc
new file mode 100644
index 0000000..78ccce0
Binary files /dev/null and b/skynet_part1/lib/__pycache__/__init__.cpython-35.pyc differ
diff --git a/skynet_part1/lib/__pycache__/comms.cpython-35.pyc b/skynet_part1/lib/__pycache__/comms.cpython-35.pyc
new file mode 100644
index 0000000..96f54cd
Binary files /dev/null and b/skynet_part1/lib/__pycache__/comms.cpython-35.pyc differ
diff --git a/skynet_part1/lib/__pycache__/evil.cpython-35.pyc b/skynet_part1/lib/__pycache__/evil.cpython-35.pyc
new file mode 100644
index 0000000..d5b3105
Binary files /dev/null and b/skynet_part1/lib/__pycache__/evil.cpython-35.pyc differ
diff --git a/skynet_part1/lib/__pycache__/files.cpython-35.pyc b/skynet_part1/lib/__pycache__/files.cpython-35.pyc
new file mode 100644
index 0000000..46b30cf
Binary files /dev/null and b/skynet_part1/lib/__pycache__/files.cpython-35.pyc differ
diff --git a/skynet_part1/lib/__pycache__/helpers.cpython-35.pyc b/skynet_part1/lib/__pycache__/helpers.cpython-35.pyc
new file mode 100644
index 0000000..086efe6
Binary files /dev/null and b/skynet_part1/lib/__pycache__/helpers.cpython-35.pyc differ
diff --git a/skynet_part1/lib/__pycache__/p2p.cpython-35.pyc b/skynet_part1/lib/__pycache__/p2p.cpython-35.pyc
new file mode 100644
index 0000000..0e537cf
Binary files /dev/null and b/skynet_part1/lib/__pycache__/p2p.cpython-35.pyc differ
diff --git a/skynet_part1/lib/comms.py b/skynet_part1/lib/comms.py
index 3ed42bd..afe2d20 100644
--- a/skynet_part1/lib/comms.py
+++ b/skynet_part1/lib/comms.py
@@ -1,6 +1,11 @@
 import struct
 
 from Crypto.Cipher import XOR
+from Crypto.Cipher import AES
+
+from Crypto.Hash import HMAC
+from Crypto.Hash import SHA256
+
 
 from dh import create_dh_key, calculate_dh_secret
 
@@ -29,11 +34,33 @@ class StealthConn(object):
             print("Shared hash: {}".format(shared_hash))
 
         # Default XOR algorithm can only take a key of length 32
-        self.cipher = XOR.new(shared_hash[:4])
+        iv = XOR.new(shared_hash[:4])
+
+        self.cipher = AES.new(shared_hash[:4], AES.MODE_CBC, iv)
+
+    def pad(s)
+        return s + b"\0" * (AES.block_size - len(s) % AES.block_size)
+
+    def send(self, data):
+        if self.cipher:
+            message = pad(data)
+            encrypted_data = self.cipher.encrypt(message)
+
+		iv = XOR.new(shared_hash[:4])
+		
+        self.cipher = AES.new(shared_hash[:4], AES.MODE_CBC, iv)
+		
+	def pad(s)
+		return s + b"\0" * (AES.block_size - len(s) % AES.block_size)
 
     def send(self, data):
         if self.cipher:
-            encrypted_data = self.cipher.encrypt(data)
+			message = pad(data)
+            encrypted_data = self.cipher.encrypt(message)
+			#implementing message authentication using HMAC
+			hmac = HMAC.new(shared_secret, digestmod=SHA256)
+			hmac.update(encrypted_data)
+
             if self.verbose:
                 print("Original data: {}".format(data))
                 print("Encrypted data: {}".format(repr(encrypted_data)))
@@ -55,10 +82,14 @@ class StealthConn(object):
         encrypted_data = self.conn.recv(pkt_len)
         if self.cipher:
             data = self.cipher.decrypt(encrypted_data)
-            if self.verbose:
-                print("Receiving packet of length {}".format(pkt_len))
-                print("Encrypted data: {}".format(repr(encrypted_data)))
-                print("Original data: {}".format(data))
+			#check if message has been modified
+			hmac_c = HMAC.new(shared_secret, digestmod=SHA256)
+			hmac_c.update(encrypted_data)
+			if hmac.hexdigest() == hmac_c.hexdigest():
+				if self.verbose:
+					print("Receiving packet of length {}".format(pkt_len))
+					print("Encrypted data: {}".format(repr(encrypted_data)))
+					print("Original data: {}".format(data))
         else:
             data = encrypted_data
 
